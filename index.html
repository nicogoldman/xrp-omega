<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XRP OMEGA | Live Microstructure Simulator</title>
    <link href="https://fonts.googleapis.com/css2?family=Syncopate:wght@400;700&family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90' font-family='sans-serif' fill='%2300f3ff'>X</text></svg>">

    <style>
        :root {
            --void: #020204;
            --hologram: rgba(0, 243, 255, 0.05);
            --cyan: #00f3ff;
            --acid: #ccff00;
            --danger: #ff2a6d;
            --glass: rgba(10, 15, 20, 0.6);
            --glass-border: rgba(0, 243, 255, 0.15);
        }

        * { box-sizing: border-box; outline: none; }

        body {
            margin: 0;
            background-color: var(--void);
            color: var(--cyan);
            font-family: 'Space Mono', monospace;
            overflow-x: hidden;
            overflow-y: auto;
            background-image: radial-gradient(circle at 50% 50%, #0a0f1e 0%, #000 100%);
            min-height: 100vh;
        }

        body::before {
            content: " ";
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 999;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle, transparent 60%, black 100%);
            z-index: 998;
            pointer-events: none;
        }

        .layout {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            min-height: 100vh;
            height: auto;
            position: relative;
            z-index: 10;
            padding-bottom: 50px;
        }

        .cyber-panel {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            padding: 25px;
            border-radius: 4px;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: 0 0 40px rgba(0,0,0,0.6);
            height: fit-content;
        }

        .header {
            text-align: center;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--glass-border);
            padding-bottom: 20px;
            position: relative;
        }

        .header::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 2px;
            background: var(--cyan);
            box-shadow: 0 0 15px var(--cyan);
        }

        .logo { font-family: 'Syncopate', sans-serif; font-weight: 700; font-size: 2rem; letter-spacing: -2px; color: white; text-shadow: 0 0 20px var(--cyan); }
        .logo span { color: var(--acid); font-size: 0.9rem; letter-spacing: 6px; display: block; margin-top: 5px; opacity: 0.9; }

        .exec-status {
            margin-top: 12px;
            display: inline-block;
            font-size: 0.7rem;
            letter-spacing: 1.6px;
            border: 1px solid #333;
            padding: 4px 10px;
            color: #666;
            background: rgba(0, 0, 0, 0.5);
        }

        .exec-status.live {
            border-color: var(--acid);
            color: var(--acid);
            text-shadow: 0 0 12px rgba(204, 255, 0, 0.6);
            box-shadow: 0 0 14px rgba(204, 255, 0, 0.3);
        }

        .control-group label { display: flex; justify-content: space-between; font-size: 0.7rem; color: #888; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }

        .cyber-input {
            background: rgba(0,0,0,0.4);
            border: 1px solid #333;
            color: white;
            padding: 12px 15px;
            width: 100%;
            font-family: 'Space Mono';
            font-size: 1.1rem;
            transition: all 0.3s ease;
            border-left: 2px solid transparent;
        }

        .cyber-input:focus {
            border-color: var(--cyan);
            border-left: 5px solid var(--cyan);
            background: rgba(0, 243, 255, 0.05);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.1);
        }

        .button-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }

        .cyber-btn {
            background: rgba(0, 243, 255, 0.08);
            border: 1px solid var(--glass-border);
            color: #fff;
            padding: 12px;
            font-family: 'Space Mono', monospace;
            font-size: 0.78rem;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
        }

        .cyber-btn:hover {
            border-color: var(--cyan);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
            color: var(--cyan);
        }

        .cyber-btn.stop {
            background: rgba(255, 42, 109, 0.08);
        }

        .cyber-btn.stop:hover {
            border-color: var(--danger);
            color: var(--danger);
            box-shadow: 0 0 15px rgba(255, 42, 109, 0.2);
        }

        .terminal {
            min-height: 190px;
            background: rgba(5, 5, 5, 0.95);
            border: 1px solid #222;
            padding: 15px;
            font-size: 0.75rem;
            overflow: hidden;
            display: flex;
            flex-direction: column-reverse;
            border-left: 3px solid var(--acid);
            position: relative;
        }

        .terminal::before {
            content: "SIMULATION LOG // XRPUSDT";
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 0.6rem;
            color: #444;
        }

        .log-line { margin-bottom: 4px; padding-left: 10px; opacity: 0; animation: fadeIn 0.3s forwards; }
        .log-line::before { content: ">"; margin-right: 8px; color: #555; }
        .log-line.ai { color: var(--acid); text-shadow: 0 0 5px rgba(204, 255, 0, 0.3); }
        .log-line.warn { color: var(--danger); }
        .log-line.normal { color: #aaa; }

        .main-deck { display: grid; grid-template-rows: auto 1fr auto; gap: 20px; }

        .metrics-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; }
        .metric-card {
            background: rgba(255,255,255,0.02);
            border: 1px solid var(--glass-border);
            padding: 15px;
            text-align: center;
            position: relative;
            overflow: hidden;
            transition: background 0.3s;
        }

        .metric-card:hover { background: rgba(255,255,255,0.05); }
        .metric-card h3 { margin: 0; font-size: 0.65rem; color: #666; letter-spacing: 2px; text-transform: uppercase; }
        .metric-card .val { font-size: 1.6rem; font-weight: 700; margin-top: 10px; color: white; font-family: 'Syncopate'; }
        .metric-card .status { font-size: 0.6rem; color: var(--cyan); margin-top: 5px; opacity: 0.8; }

        .singularity-container {
            position: relative;
            border: 1px solid var(--glass-border);
            box-shadow: inset 0 0 100px rgba(0,0,0,0.9);
            background: radial-gradient(circle, #0d121d 0%, #000 90%);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border-radius: 2px;
            min-height: 400px;
        }

        canvas#nexus { position: absolute; top:0; left:0; width:100%; height:100%; z-index: 1; opacity: 0.8; }

        .center-data { z-index: 2; text-align: center; pointer-events: none; mix-blend-mode: screen; }
        .big-price {
            font-size: 5rem;
            font-family: 'Syncopate';
            font-weight: 700;
            color: white;
            letter-spacing: -4px;
            line-height: 1;
            text-shadow: 0 0 40px rgba(0, 243, 255, 0.3);
        }

        .sub-price { font-size: 1rem; color: var(--acid); letter-spacing: 8px; text-transform: uppercase; margin-bottom: 10px; }

        .connect-status {
            margin-top: 15px;
            font-size: 0.7rem;
            letter-spacing: 2px;
            display: inline-block;
            padding: 4px 10px;
            border: 1px solid #333;
            background: black;
        }

        .wealth-bar {
            background: linear-gradient(90deg, rgba(10,20,15,0.9) 0%, rgba(5,10,5,1) 100%);
            border: 1px solid var(--acid);
            padding: 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 0 20px rgba(204, 255, 0, 0.1);
            position: relative;
            overflow: hidden;
            flex-wrap: wrap;
            gap: 15px;
        }

        .wealth-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 50%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(204,255,0,0.1), transparent);
            animation: shine 6s infinite;
        }

        .wealth-total {
            font-size: 2.5rem;
            color: var(--acid);
            font-weight: 700;
            text-shadow: 0 0 15px rgba(204, 255, 0, 0.4);
            font-family: 'Syncopate';
            word-break: break-all;
        }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes shine { 0% { left: -100%; } 20% { left: 200%; } 100% { left: 200%; } }

        @media (max-width: 1100px) {
            .layout { grid-template-columns: 1fr; height: auto; display: flex; flex-direction: column; }
            .metrics-grid { grid-template-columns: repeat(2, 1fr); }
            .singularity-container { height: 350px; min-height: 350px; }
            .big-price { font-size: 3.5rem; }
            .cyber-panel { order: 2; }
            .main-deck { order: 1; }
        }

        @media (max-width: 600px) {
            .big-price { font-size: 2.8rem; }
            .wealth-total { font-size: 1.8rem; }
            .wealth-bar { flex-direction: column; text-align: center; }
            .metric-card .val { font-size: 1.2rem; }
        }
    </style>
</head>
<body>
<div class="layout">
    <div class="cyber-panel">
        <div class="header">
            <div class="logo">OMEGA <span>MICROSTRUCTURE SIM</span></div>
            <div class="exec-status" id="execStatus">STANDBY</div>
        </div>

        <div class="control-group">
            <label><span>Comisión por Trade</span> <span>FEE</span></label>
            <input type="text" class="cyber-input" value="0.10%" readonly>
        </div>

        <div class="button-grid">
            <button id="startBtn" class="cyber-btn">INICIAR PROTOCOLO OMEGA</button>
            <button id="stopBtn" class="cyber-btn stop">TERMINAR SESIÓN</button>
        </div>

        <div class="terminal" id="terminal"></div>
    </div>

    <div class="main-deck">
        <div class="metrics-grid">
            <div class="metric-card">
                <h3>Omega Index</h3>
                <div class="val" id="omegaVal">50.00</div>
                <div class="status" id="omegaText">NEUTRAL FIELD</div>
            </div>
            <div class="metric-card">
                <h3>Portfolio Value (USD)</h3>
                <div class="val" id="portfolioVal">$0.00</div>
                <div class="status" id="positionStatus">POSITION: XRP</div>
            </div>
            <div class="metric-card">
                <h3>ROI Alpha %</h3>
                <div class="val" id="roiVal">0.00%</div>
                <div class="status">VS INITIAL VALUE</div>
            </div>
            <div class="metric-card">
                <h3>Flow / LIQ</h3>
                <div class="val" id="flowVal">0.00</div>
                <div class="status" id="liqVal">LIQ: 0.0000</div>
            </div>
        </div>

        <div class="singularity-container">
            <canvas id="nexus"></canvas>
            <div class="center-data">
                <div class="sub-price">XRPUSDT LAST PRICE</div>
                <div class="big-price" id="mainPrice">0.0000</div>
                <div class="connect-status" id="connectStatus" style="color:#666">LINK IDLE</div>
            </div>
        </div>

        <div class="wealth-bar">
            <div>
                <label style="color:white; font-size:0.8rem; display:block; letter-spacing:1px; margin-bottom:5px;">SIMULATED PORTFOLIO</label>
                <small style="color:#888; font-family:'Space Mono';">Browser-memory only. Public market data only. No real trading.</small>
            </div>
            <div class="wealth-total" id="wealthTotal">$0.00</div>
        </div>
    </div>
</div>

<script>
    const FEE_RATE = 0.001;

    const state = {
        price: 0,
        balanceXRP: 1000,
        balanceUSDT: 0,
        position: 'XRP',
        initialValueUSD: null,
        active: false,
        omega: 50,
        flowDelta: 0,
        liqImbalance: 0,
        lastPrice: 0,
        lastWallAlertAt: 0
    };

    const els = {
        price: document.getElementById('mainPrice'),
        connect: document.getElementById('connectStatus'),
        term: document.getElementById('terminal'),
        omegaVal: document.getElementById('omegaVal'),
        omegaText: document.getElementById('omegaText'),
        portfolioVal: document.getElementById('portfolioVal'),
        roiVal: document.getElementById('roiVal'),
        positionStatus: document.getElementById('positionStatus'),
        flowVal: document.getElementById('flowVal'),
        liqVal: document.getElementById('liqVal'),
        wealthTotal: document.getElementById('wealthTotal'),
        execStatus: document.getElementById('execStatus'),
        startBtn: document.getElementById('startBtn'),
        stopBtn: document.getElementById('stopBtn')
    };

    const canvas = document.getElementById('nexus');
    const ctx = canvas.getContext('2d');
    let width = 0;
    let height = 0;
    let particles = [];

    function resizeCanvas() {
        width = canvas.width = canvas.parentElement.offsetWidth;
        height = canvas.height = canvas.parentElement.offsetHeight;
        initParticles();
    }

    function initParticles() {
        particles = Array.from({ length: 70 }, () => ({
            x: Math.random() * width,
            y: Math.random() * height,
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5,
            size: Math.random() * 2 + 0.5,
            phase: Math.random() * Math.PI * 2
        }));
    }

    function drawNexus() {
        ctx.fillStyle = 'rgba(5, 8, 16, 0.15)';
        ctx.fillRect(0, 0, width, height);

        const omegaDrift = (state.omega - 50) / 50;
        const baseColor = omegaDrift >= 0
            ? { r: 204, g: 255, b: 0 }
            : { r: 255, g: 42, b: 109 };

        particles.forEach((p, i) => {
            p.x += p.vx;
            p.y += p.vy;

            if (p.x < 0 || p.x > width) p.vx *= -1;
            if (p.y < 0 || p.y > height) p.vy *= -1;

            p.phase += 0.05;
            const currentSize = p.size + Math.sin(p.phase) * 0.5;

            ctx.beginPath();
            ctx.arc(p.x, p.y, Math.max(0, currentSize), 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, 0.8)`;
            ctx.fill();

            for (let j = i + 1; j < particles.length; j++) {
                const p2 = particles[j];
                const dx = p.x - p2.x;
                const dy = p.y - p2.y;
                const distSq = dx * dx + dy * dy;

                if (distSq < 10000) {
                    const alpha = 1 - (distSq / 10000);
                    ctx.beginPath();
                    ctx.strokeStyle = `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, ${alpha * 0.4})`;
                    ctx.lineWidth = 0.5;
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            }
        });

        requestAnimationFrame(drawNexus);
    }

    async function fetchTickerPrice() {
        const res = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=XRPUSDT');
        if (!res.ok) throw new Error('Ticker unavailable');
        const data = await res.json();
        state.price = parseFloat(data.price);
    }

    async function fetchOrderBook() {
        const res = await fetch('https://api.binance.com/api/v3/depth?symbol=XRPUSDT&limit=500');
        if (!res.ok) throw new Error('Order book unavailable');
        const data = await res.json();

        let totalBids = 0;
        let totalAsks = 0;

        data.bids.forEach(level => {
            totalBids += parseFloat(level[1]);
        });

        data.asks.forEach(level => {
            totalAsks += parseFloat(level[1]);
        });

        const den = totalBids + totalAsks;
        state.liqImbalance = den === 0 ? 0 : (totalBids - totalAsks) / den;

        if (Math.abs(state.liqImbalance) > 0.4) {
            const now = Date.now();
            if (now - state.lastWallAlertAt > 12000) {
                log('LIQUIDITY WALL DETECTED', 'warn');
                state.lastWallAlertAt = now;
            }
        }
    }

    async function fetchTrades() {
        const res = await fetch('https://api.binance.com/api/v3/trades?symbol=XRPUSDT&limit=500');
        if (!res.ok) throw new Error('Trades unavailable');
        const trades = await res.json();

        let buyQty = 0;
        let sellQty = 0;

        trades.forEach(t => {
            const qty = parseFloat(t.qty);
            if (t.isBuyerMaker === false) {
                buyQty += qty;
            } else {
                sellQty += qty;
            }
        });

        state.flowDelta = buyQty - sellQty;
    }

    function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    function computeOmega() {
        const priceVelocity = state.price - state.lastPrice;
        const rawOmega = (state.flowDelta * state.liqImbalance) - (priceVelocity * 10);
        state.omega = clamp(50 + rawOmega, 0, 100);
        state.lastPrice = state.price;
    }

    function runTradingLogic() {
        if (!state.active) return;

        if (state.omega > 85 && state.position === 'USDT' && state.balanceUSDT > 0) {
            const usdtToSpend = state.balanceUSDT;
            const grossXrp = usdtToSpend / state.price;
            const feeXrp = grossXrp * FEE_RATE;
            const netXrp = grossXrp - feeXrp;

            state.balanceXRP += netXrp;
            state.balanceUSDT = 0;
            state.position = 'XRP';

            logTrade('BUY', state.price, feeXrp, 'XRP');
        }

        if (state.omega < 15 && state.position === 'XRP' && state.balanceXRP > 0) {
            const xrpToSell = state.balanceXRP;
            const grossUsdt = xrpToSell * state.price;
            const feeUsdt = grossUsdt * FEE_RATE;
            const netUsdt = grossUsdt - feeUsdt;

            state.balanceUSDT += netUsdt;
            state.balanceXRP = 0;
            state.position = 'USDT';

            logTrade('SELL', state.price, feeUsdt, 'USDT');
        }
    }

    function logTrade(side, price, feeValue, feeAsset) {
        const info = `${side} @ ${price.toFixed(5)} | Fee: ${feeValue.toFixed(5)} ${feeAsset} | Balances => XRP ${state.balanceXRP.toFixed(4)} / USDT ${state.balanceUSDT.toFixed(4)}`;
        log(info, side === 'BUY' ? 'ai' : 'warn');
    }

    function getPortfolioValueUSD() {
        return state.balanceUSDT + (state.balanceXRP * state.price);
    }

    function updateUI() {
        els.price.innerText = state.price ? state.price.toFixed(5) : '0.00000';

        els.omegaVal.innerText = state.omega.toFixed(2);
        if (state.omega > 85) {
            els.omegaVal.style.color = '#ccff00';
            els.omegaText.textContent = 'ENTRY BIAS > 85';
        } else if (state.omega < 15) {
            els.omegaVal.style.color = '#ff2a6d';
            els.omegaText.textContent = 'EXIT BIAS < 15';
        } else {
            els.omegaVal.style.color = 'white';
            els.omegaText.textContent = 'NEUTRAL FIELD';
        }

        els.flowVal.innerText = state.flowDelta.toFixed(2);
        els.liqVal.innerText = `LIQ: ${state.liqImbalance.toFixed(4)}`;

        const portfolio = getPortfolioValueUSD();
        els.portfolioVal.innerText = `$${portfolio.toFixed(2)}`;
        els.wealthTotal.innerText = `$${portfolio.toFixed(2)}`;
        els.positionStatus.innerText = `POSITION: ${state.position}`;

        if (state.initialValueUSD === null && state.price > 0) {
            state.initialValueUSD = portfolio;
            log(`INITIAL VALUE LOCKED: $${state.initialValueUSD.toFixed(2)}`, 'normal');
        }

        let roi = 0;
        if (state.initialValueUSD && state.initialValueUSD > 0) {
            roi = ((portfolio - state.initialValueUSD) / state.initialValueUSD) * 100;
        }
        els.roiVal.innerText = `${roi.toFixed(2)}%`;
        els.roiVal.style.color = roi >= 0 ? '#ccff00' : '#ff2a6d';
    }

    function updateExecutionStatus() {
        if (state.active) {
            els.execStatus.innerText = 'EXECUTING';
            els.execStatus.classList.add('live');
        } else {
            els.execStatus.innerText = 'STANDBY';
            els.execStatus.classList.remove('live');
        }
    }

    function log(msg, type = 'normal') {
        const div = document.createElement('div');
        div.className = `log-line ${type}`;
        div.innerText = msg;
        els.term.prepend(div);
        if (els.term.children.length > 12) els.term.lastChild.remove();
    }

    async function tick() {
        try {
            await Promise.all([fetchTickerPrice(), fetchOrderBook(), fetchTrades()]);
            computeOmega();
            runTradingLogic();
            updateUI();

            els.connect.innerText = 'PUBLIC BINANCE FEED ONLINE';
            els.connect.style.color = '#00f3ff';
            els.connect.style.borderColor = '#00f3ff';
        } catch (err) {
            els.connect.innerText = 'FEED DEGRADED - RETRYING';
            els.connect.style.color = '#ff2a6d';
            els.connect.style.borderColor = '#ff2a6d';
            log(`DATA LOOP WARNING: ${err.message}`, 'warn');
        }
    }

    function attachControls() {
        els.startBtn.addEventListener('click', () => {
            state.active = true;
            updateExecutionStatus();
            log('PROTOCOLO OMEGA ACTIVADO', 'ai');
        });

        els.stopBtn.addEventListener('click', () => {
            state.active = false;
            updateExecutionStatus();
            log('SESIÓN TERMINADA - STANDBY', 'normal');
        });
    }

    async function initSystem() {
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        drawNexus();
        attachControls();
        updateExecutionStatus();

        log('SIMULATION ONLY // NO REAL TRADING', 'warn');
        log('BOOTING MICROSTRUCTURE ENGINE...', 'normal');

        await tick();
        setInterval(tick, 4000);
    }

    initSystem();
</script>
</body>
</html>
