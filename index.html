<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XRP OMEGA | Live Microstructure Simulator</title>
    <link href="https://fonts.googleapis.com/css2?family=Syncopate:wght@400;700&family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90' font-family='sans-serif' fill='%2300f3ff'>X</text></svg>">
    <style>
        :root {
            --void: #020204;
            --hologram: rgba(0, 243, 255, 0.05);
            --cyan: #00f3ff;
            --acid: #ccff00;
            --danger: #ff2a6d;
            --glass: rgba(10, 15, 20, 0.6);
            --glass-border: rgba(0, 243, 255, 0.15);
        }

        * { box-sizing: border-box; outline: none; }

        body {
            margin: 0;
            background-color: var(--void);
            color: var(--cyan);
            font-family: 'Space Mono', monospace;
            overflow-x: hidden;
            overflow-y: auto;
            background-image: radial-gradient(circle at 50% 50%, #0a0f1e 0%, #000 100%);
            min-height: 100vh;
        }

        body::before {
            content: " "; display: block; position: fixed; top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 999; background-size: 100% 2px, 3px 100%; pointer-events: none;
        }

        body::after {
            content: ""; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: radial-gradient(circle, transparent 60%, black 100%);
            z-index: 998; pointer-events: none;
        }

        .layout {
            max-width: 1800px; margin: 0 auto; padding: 20px;
            display: grid; grid-template-columns: 350px 1fr; gap: 20px;
            min-height: 100vh;
            height: auto;
            position: relative; z-index: 10;
            padding-bottom: 50px;
        }

        .cyber-panel {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            padding: 25px;
            border-radius: 4px;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            display: flex; flex-direction: column; gap: 20px;
            box-shadow: 0 0 40px rgba(0,0,0,0.6);
            height: fit-content;
        }

        .header { text-align: center; margin-bottom: 10px; border-bottom: 1px solid var(--glass-border); padding-bottom: 20px; position: relative; }
        .header::after {
            content: ''; position: absolute; bottom: -1px; left: 50%; transform: translateX(-50%);
            width: 60px; height: 2px; background: var(--cyan); box-shadow: 0 0 15px var(--cyan);
        }

        .logo { font-family: 'Syncopate', sans-serif; font-weight: 700; font-size: 2rem; letter-spacing: -2px; color: white; text-shadow: 0 0 20px var(--cyan); }
        .logo span { color: var(--acid); font-size: 0.9rem; letter-spacing: 6px; display: block; margin-top: 5px; opacity: 0.9; }

        .header-tag {
            margin-top: 12px;
            font-size: 0.72rem;
            letter-spacing: 1.8px;
            border: 1px solid #2c2c2c;
            display: inline-block;
            padding: 4px 10px;
            color: #777;
            background: rgba(0,0,0,0.7);
            text-transform: uppercase;
        }

        .header-tag.executing {
            color: var(--acid);
            border-color: rgba(204,255,0,0.65);
            box-shadow: 0 0 18px rgba(204,255,0,0.4);
            text-shadow: 0 0 8px rgba(204,255,0,0.5);
        }

        .control-group label { display: flex; justify-content: space-between; font-size: 0.7rem; color: #888; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }

        .cyber-input {
            background: rgba(0,0,0,0.4);
            border: 1px solid #333;
            color: white;
            padding: 12px 15px;
            width: 100%;
            font-family: 'Space Mono';
            font-size: 1.1rem;
            border-left: 2px solid transparent;
        }

        .action-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }

        .action-btn {
            background: rgba(0, 243, 255, 0.08);
            color: var(--cyan);
            border: 1px solid var(--glass-border);
            padding: 11px 14px;
            font-family: 'Space Mono', monospace;
            font-size: 0.82rem;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
        }

        .action-btn:hover {
            border-color: var(--cyan);
            box-shadow: 0 0 16px rgba(0,243,255,0.25);
        }

        .action-btn.stop {
            border-color: rgba(255, 42, 109, 0.45);
            color: #ff7fa8;
            background: rgba(255, 42, 109, 0.08);
        }

        .terminal {
            min-height: 170px;
            background: rgba(5, 5, 5, 0.95);
            border: 1px solid #222;
            padding: 15px;
            font-size: 0.72rem;
            overflow: hidden;
            display: flex; flex-direction: column-reverse;
            border-left: 3px solid var(--acid);
            position: relative;
        }

        .terminal::before {
            content: "SYSTEM LOG // MICROSTRUCTURE";
            position: absolute; top: 5px; right: 10px; font-size: 0.6rem; color: #444;
        }

        .log-line { margin-bottom: 4px; padding-left: 10px; opacity: 0; animation: fadeIn 0.3s forwards; }
        .log-line::before { content: ">"; margin-right: 8px; color: #555; }
        .log-line.ai { color: var(--acid); text-shadow: 0 0 5px rgba(204, 255, 0, 0.3); }
        .log-line.warn { color: var(--danger); }
        .log-line.normal { color: #aaa; }

        .main-deck { display: grid; grid-template-rows: auto 1fr auto; gap: 20px; }

        .metrics-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; }
        .metric-card {
            background: rgba(255,255,255,0.02);
            border: 1px solid var(--glass-border);
            padding: 15px; text-align: center;
            position: relative; overflow: hidden;
            transition: background 0.3s;
        }
        .metric-card:hover { background: rgba(255,255,255,0.05); }
        .metric-card h3 { margin: 0; font-size: 0.65rem; color: #666; letter-spacing: 2px; text-transform: uppercase; }
        .metric-card .val { font-size: 1.4rem; font-weight: 700; margin-top: 10px; color: white; font-family: 'Syncopate'; }
        .metric-card .status { font-size: 0.6rem; color: var(--cyan); margin-top: 5px; opacity: 0.8; }

        .singularity-container {
            position: relative;
            border: 1px solid var(--glass-border);
            box-shadow: inset 0 0 100px rgba(0,0,0,0.9);
            background: radial-gradient(circle, #0d121d 0%, #000 90%);
            display: flex; align-items: center; justify-content: center;
            overflow: hidden;
            border-radius: 2px;
            min-height: 400px;
        }
        canvas#nexus { position: absolute; top:0; left:0; width:100%; height:100%; z-index: 1; opacity: 0.8; }

        .center-data { z-index: 2; text-align: center; pointer-events: none; mix-blend-mode: screen; }
        .big-price {
            font-size: 5rem; font-family: 'Syncopate'; font-weight: 700; color: white;
            letter-spacing: -4px; line-height: 1;
            text-shadow: 0 0 40px rgba(0, 243, 255, 0.3);
        }
        .sub-price { font-size: 1rem; color: var(--acid); letter-spacing: 8px; text-transform: uppercase; margin-bottom: 10px; }

        .connect-status {
            margin-top: 15px; font-size: 0.7rem; letter-spacing: 2px;
            display: inline-block; padding: 4px 10px; border: 1px solid #333; background: black;
        }

        .wealth-bar {
            background: linear-gradient(90deg, rgba(10,20,15,0.9) 0%, rgba(5,10,5,1) 100%);
            border: 1px solid var(--acid);
            padding: 25px;
            display: flex; justify-content: space-between; align-items: center;
            box-shadow: 0 0 20px rgba(204, 255, 0, 0.1);
            position: relative; overflow: hidden;
            flex-wrap: wrap;
            gap: 15px;
        }

        .wealth-bar::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 50%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(204,255,0,0.1), transparent);
            animation: shine 6s infinite;
        }

        .wealth-total { font-size: 2.5rem; color: var(--acid); font-weight: 700; text-shadow: 0 0 15px rgba(204, 255, 0, 0.4); font-family: 'Syncopate'; word-break: break-all; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes shine { 0% { left: -100%; } 20% { left: 200%; } 100% { left: 200%; } }

        @media (max-width: 1100px) {
            .layout { grid-template-columns: 1fr; height: auto; display: flex; flex-direction: column; }
            .metrics-grid { grid-template-columns: repeat(2, 1fr); }
            .singularity-container { height: 350px; min-height: 350px; }
            .big-price { font-size: 3.5rem; }
            .cyber-panel { order: 2; }
            .main-deck { order: 1; }
        }

        @media (max-width: 600px) {
            .big-price { font-size: 2.8rem; }
            .wealth-total { font-size: 1.8rem; }
            .wealth-bar { flex-direction: column; text-align: center; }
            .metric-card .val { font-size: 1.1rem; }
        }
    </style>
</head>
<body>
<div class="layout">
    <div class="cyber-panel">
        <div class="header">
            <div class="logo">OMEGA <span>INTERFACE</span></div>
            <div class="header-tag" id="sessionTag">STANDBY</div>
        </div>

        <div class="control-group">
            <label><span>Balance XRP</span> <span id="xrpBalanceLabel">1000.0000 XRP</span></label>
            <input type="text" class="cyber-input" id="xrpInput" value="1000.0000" disabled>
        </div>

        <div class="control-group">
            <label><span>Balance USDT</span> <span id="usdtBalanceLabel">0.0000 USDT</span></label>
            <input type="text" class="cyber-input" id="usdtInput" value="0.0000" disabled>
        </div>

        <div class="action-grid">
            <button class="action-btn" id="startBtn">INICIAR PROTOCOLO OMEGA</button>
            <button class="action-btn stop" id="stopBtn">TERMINAR SESIÃ“N</button>
        </div>

        <div class="terminal" id="terminal"></div>
    </div>

    <div class="main-deck">
        <div class="metrics-grid">
            <div class="metric-card">
                <h3>OMEGA INDEX</h3>
                <div class="val" id="omegaVal">50.00</div>
                <div class="status" id="omegaText">NEUTRAL FLOW</div>
            </div>
            <div class="metric-card">
                <h3>PORTFOLIO VALUE (USD)</h3>
                <div class="val" id="portfolioVal">$0.00</div>
                <div class="status">SIMULATION MEMORY</div>
            </div>
            <div class="metric-card">
                <h3>ROI ALPHA %</h3>
                <div class="val" id="roiVal">0.00%</div>
                <div class="status" id="roiText">BASELINE</div>
            </div>
            <div class="metric-card">
                <h3>LIQUIDITY IMBALANCE</h3>
                <div class="val" id="liqVal">0.00%</div>
                <div class="status" id="liqText">BALANCED</div>
            </div>
        </div>

        <div class="singularity-container">
            <canvas id="nexus"></canvas>
            <div class="center-data">
                <div class="sub-price">XRPUSDT MARKET</div>
                <div class="big-price" id="mainPrice">$0.0000</div>
                <div class="connect-status" id="connectStatus" style="color:#666">STANDBY // NO EXECUTION</div>
            </div>
        </div>

        <div class="wealth-bar">
            <div>
                <label style="color:white; font-size:0.8rem; display:block; letter-spacing:1px; margin-bottom:5px;">SIMULATED PORTFOLIO VALUE</label>
                <small style="color:#888; font-family:'Space Mono';">No real trading. Public Binance market data only.</small>
            </div>
            <div class="wealth-total" id="wealthTotal">$0.00</div>
        </div>
    </div>
</div>

<script>
    const FEE_RATE = 0.001;

    const state = {
        price: 0,
        balanceXRP: 1000,
        balanceUSDT: 0,
        position: "XRP",
        initialValueUSD: null,
        active: false,
        omega: 50,
        flowDelta: 0,
        liqImbalance: 0,
        lastPrice: 0,
        volume: 0,
        change24h: 0
    };

    const els = {
        term: document.getElementById('terminal'),
        price: document.getElementById('mainPrice'),
        status: document.getElementById('connectStatus'),
        sessionTag: document.getElementById('sessionTag'),
        startBtn: document.getElementById('startBtn'),
        stopBtn: document.getElementById('stopBtn'),
        omegaVal: document.getElementById('omegaVal'),
        omegaText: document.getElementById('omegaText'),
        portfolioVal: document.getElementById('portfolioVal'),
        roiVal: document.getElementById('roiVal'),
        roiText: document.getElementById('roiText'),
        liqVal: document.getElementById('liqVal'),
        liqText: document.getElementById('liqText'),
        wealthTotal: document.getElementById('wealthTotal'),
        xrpInput: document.getElementById('xrpInput'),
        usdtInput: document.getElementById('usdtInput'),
        xrpBalanceLabel: document.getElementById('xrpBalanceLabel'),
        usdtBalanceLabel: document.getElementById('usdtBalanceLabel')
    };

    const canvas = document.getElementById('nexus');
    const ctx = canvas.getContext('2d');
    let width, height;
    let particles = [];

    function resizeCanvas() {
        width = canvas.width = canvas.parentElement.offsetWidth;
        height = canvas.height = canvas.parentElement.offsetHeight;
        initParticles();
    }

    function initParticles() {
        particles = Array.from({ length: 70 }, () => ({
            x: Math.random() * width,
            y: Math.random() * height,
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5,
            size: Math.random() * 2 + 0.5,
            phase: Math.random() * Math.PI * 2
        }));
    }

    function drawNexus() {
        ctx.fillStyle = 'rgba(5, 8, 16, 0.15)';
        ctx.fillRect(0, 0, width, height);

        const pulse = state.omega >= 50 ? { r: 204, g: 255, b: 0 } : { r: 255, g: 42, b: 109 };

        particles.forEach((p, i) => {
            p.x += p.vx;
            p.y += p.vy;

            if (p.x < 0 || p.x > width) p.vx *= -1;
            if (p.y < 0 || p.y > height) p.vy *= -1;

            p.phase += 0.05;
            const currentSize = p.size + Math.sin(p.phase) * 0.5;

            ctx.beginPath();
            ctx.arc(p.x, p.y, Math.max(0, currentSize), 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${pulse.r}, ${pulse.g}, ${pulse.b}, 0.8)`;
            ctx.fill();

            for (let j = i + 1; j < particles.length; j++) {
                const p2 = particles[j];
                const dx = p.x - p2.x;
                const dy = p.y - p2.y;
                const distSq = dx * dx + dy * dy;
                if (distSq < 10000) {
                    const alpha = 1 - (distSq / 10000);
                    ctx.beginPath();
                    ctx.strokeStyle = `rgba(${pulse.r}, ${pulse.g}, ${pulse.b}, ${alpha * 0.4})`;
                    ctx.lineWidth = 0.5;
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            }
        });

        requestAnimationFrame(drawNexus);
    }

    function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
    }

    function log(msg, type = 'normal') {
        const div = document.createElement('div');
        div.className = `log-line ${type}`;
        div.innerText = msg;
        els.term.prepend(div);
        if (els.term.children.length > 16) {
            els.term.lastChild.remove();
        }
    }

    function formatUSD(n) {
        return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD',
            maximumFractionDigits: 2
        }).format(n);
    }

    function updateSessionTag() {
        if (state.active) {
            els.sessionTag.textContent = 'EXECUTING';
            els.sessionTag.classList.add('executing');
            els.status.textContent = 'LIVE LOOP // EXECUTING';
            els.status.style.color = '#ccff00';
            els.status.style.borderColor = '#ccff00';
        } else {
            els.sessionTag.textContent = 'STANDBY';
            els.sessionTag.classList.remove('executing');
            els.status.textContent = 'STANDBY // NO EXECUTION';
            els.status.style.color = '#777';
            els.status.style.borderColor = '#333';
        }
    }

    function getPortfolioValueUSD() {
        return state.balanceUSDT + (state.balanceXRP * state.price);
    }

    function updatePortfolioUI() {
        const value = getPortfolioValueUSD();
        if (state.initialValueUSD === null && state.price > 0) {
            state.initialValueUSD = value;
        }

        const roi = state.initialValueUSD ? ((value - state.initialValueUSD) / state.initialValueUSD) * 100 : 0;

        els.portfolioVal.textContent = formatUSD(value);
        els.wealthTotal.textContent = formatUSD(value);

        els.roiVal.textContent = `${roi.toFixed(2)}%`;
        if (roi > 0) {
            els.roiVal.style.color = '#ccff00';
            els.roiText.textContent = 'ALPHA POSITIVE';
        } else if (roi < 0) {
            els.roiVal.style.color = '#ff2a6d';
            els.roiText.textContent = 'DRAWDOWN';
        } else {
            els.roiVal.style.color = 'white';
            els.roiText.textContent = 'BASELINE';
        }

        els.xrpInput.value = state.balanceXRP.toFixed(4);
        els.usdtInput.value = state.balanceUSDT.toFixed(4);
        els.xrpBalanceLabel.textContent = `${state.balanceXRP.toFixed(4)} XRP`;
        els.usdtBalanceLabel.textContent = `${state.balanceUSDT.toFixed(4)} USDT`;
    }

    function updateOmegaUI() {
        els.omegaVal.textContent = state.omega.toFixed(2);

        if (state.omega > 85) {
            els.omegaVal.style.color = '#ccff00';
            els.omegaText.textContent = 'BUY PRESSURE';
        } else if (state.omega < 15) {
            els.omegaVal.style.color = '#ff2a6d';
            els.omegaText.textContent = 'SELL PRESSURE';
        } else {
            els.omegaVal.style.color = 'white';
            els.omegaText.textContent = 'NEUTRAL FLOW';
        }

        const liqPct = state.liqImbalance * 100;
        els.liqVal.textContent = `${liqPct.toFixed(2)}%`;
        if (Math.abs(state.liqImbalance) > 0.4) {
            els.liqVal.style.color = '#ff2a6d';
            els.liqText.textContent = 'WALL DETECTED';
        } else {
            els.liqVal.style.color = '#00f3ff';
            els.liqText.textContent = 'BALANCED';
        }
    }

    async function fetchTicker() {
        const res = await fetch('https://api.binance.com/api/v3/ticker/24hr?symbol=XRPUSDT');
        if (!res.ok) throw new Error('ticker error');
        const data = await res.json();
        state.price = parseFloat(data.lastPrice);
        state.volume = parseFloat(data.quoteVolume);
        state.change24h = parseFloat(data.priceChangePercent);
        els.price.textContent = `$${state.price.toFixed(4)}`;
    }

    async function fetchOrderBook() {
        const res = await fetch('https://api.binance.com/api/v3/depth?symbol=XRPUSDT&limit=500');
        if (!res.ok) throw new Error('depth error');
        const data = await res.json();

        const totalBids = data.bids.reduce((sum, level) => sum + parseFloat(level[1]), 0);
        const totalAsks = data.asks.reduce((sum, level) => sum + parseFloat(level[1]), 0);
        const total = totalBids + totalAsks;

        state.liqImbalance = total === 0 ? 0 : (totalBids - totalAsks) / total;

        if (Math.abs(state.liqImbalance) > 0.4) {
            log('LIQUIDITY WALL DETECTED', 'warn');
        }
    }

    async function fetchTrades() {
        const res = await fetch('https://api.binance.com/api/v3/trades?symbol=XRPUSDT&limit=500');
        if (!res.ok) throw new Error('trades error');
        const trades = await res.json();

        let buyQty = 0;
        let sellQty = 0;

        trades.forEach((trade) => {
            const qty = parseFloat(trade.qty);
            if (trade.isBuyerMaker === false) {
                buyQty += qty;
            } else {
                sellQty += qty;
            }
        });

        state.flowDelta = buyQty - sellQty;
    }

    function computeOmega() {
        const priceVelocity = state.lastPrice === 0 ? 0 : (state.price - state.lastPrice);
        const rawOmega = (state.flowDelta * state.liqImbalance) - (priceVelocity * 10);
        state.omega = clamp(50 + rawOmega, 0, 100);
        state.lastPrice = state.price;
    }

    function executeBuy() {
        if (state.balanceUSDT <= 0 || state.price <= 0) return;

        const grossXrp = state.balanceUSDT / state.price;
        const feeXrp = grossXrp * FEE_RATE;
        const netXrp = grossXrp - feeXrp;

        state.balanceUSDT = 0;
        state.balanceXRP += netXrp;
        state.position = 'XRP';

        log(`BUY @ ${state.price.toFixed(4)} | Fee ${feeXrp.toFixed(4)} XRP | XRP ${state.balanceXRP.toFixed(4)} | USDT ${state.balanceUSDT.toFixed(4)}`, 'ai');
    }

    function executeSell() {
        if (state.balanceXRP <= 0 || state.price <= 0) return;

        const grossUsdt = state.balanceXRP * state.price;
        const feeUsdt = grossUsdt * FEE_RATE;
        const netUsdt = grossUsdt - feeUsdt;

        state.balanceXRP = 0;
        state.balanceUSDT += netUsdt;
        state.position = 'USDT';

        log(`SELL @ ${state.price.toFixed(4)} | Fee ${feeUsdt.toFixed(4)} USDT | XRP ${state.balanceXRP.toFixed(4)} | USDT ${state.balanceUSDT.toFixed(4)}`, 'warn');
    }

    function runTradingLogic() {
        if (!state.active) return;

        if (state.omega > 85 && state.position === 'USDT') {
            executeBuy();
        }

        if (state.omega < 15 && state.position === 'XRP') {
            executeSell();
        }
    }

    async function dataLoop() {
        try {
            await fetchTicker();
            await fetchOrderBook();
            await fetchTrades();
            computeOmega();
            runTradingLogic();
            updateOmegaUI();
            updatePortfolioUI();
        } catch (e) {
            log(`DATA LOOP WARNING: ${e.message}`, 'warn');
        }
    }

    function bindControls() {
        els.startBtn.addEventListener('click', () => {
            state.active = true;
            updateSessionTag();
            log('OMEGA PROTOCOL ACTIVATED', 'ai');
        });

        els.stopBtn.addEventListener('click', () => {
            state.active = false;
            updateSessionTag();
            log('SESSION TERMINATED // STANDBY', 'normal');
        });
    }

    function init() {
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        drawNexus();
        bindControls();
        updateSessionTag();
        log('SIMULATION ONLY // NO REAL TRADING', 'normal');
        log('PUBLIC BINANCE DATA LINK ONLINE', 'normal');

        dataLoop();
        setInterval(dataLoop, 4000);
    }

    init();
</script>
</body>
</html>
